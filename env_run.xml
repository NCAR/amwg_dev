<?xml version="1.0"?>
<file id="env_run.xml" version="2.0">
  <header>
    These variables MAY BE CHANGED ANYTIME during a run.
    Additional machine speific variables that can be changed
    during a run are contained in the env_mach_specific file
    Note1: users SHOULD NOT modify BUILD_COMPETE in env_build.xml
    this is done automatically by the scripts.
    </header>
  <group id="run_coupling">
    <entry id="COUPLING_MODE" value="cesm">
      <type>char</type>
      <valid_values>cesm</valid_values>
      <desc>coupling mode</desc>
    </entry>
    <entry id="CPL_I2O_PER_CAT" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>determine if per ice thickness category fields are passed from ice to ocean - DO NOT EDIT (set by POP build-namelist)</desc>
    </entry>
    <entry id="ADD_AOFLUX_TO_RUNSEQ" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>add aoflux calculation to runseq</desc>
    </entry>
    <entry id="CCSM_BGC" value="CO2A">
      <type>char</type>
      <valid_values>none,CO2A,CO2B,CO2C</valid_values>
      <desc>Activates additional CO2-related fields to be exchanged between components. Possible values are:

    CO2A: sets the driver namelist variable flds_co2a = .true.; this adds
    prognostic CO2 and diagnostic CO2 at the lowest model level to be sent from
    the atmosphere to the land and ocean.

    CO2B: sets the driver namelist variable flds_co2b = .true.; this adds
    prognostic CO2 and diagnostic CO2 at the lowest model level to be sent from
    the atmosphere just to the land, and the surface upward flux of CO2 to be
    sent from the land back to the atmosphere

    CO2C: sets the driver namelist variable flds_co2c = .true.; this adds
    prognostic CO2 and diagnostic CO2 at the lowest model level to be sent from
    the atmosphere to the land and ocean, and the surface upward flux of CO2
    to be sent from the land and the open ocean back to the atmosphere.

    The namelist variables flds_co2a, flds_co2b and flds_co2c are in the
    namelist group cpl_flds_inparm.
    </desc>
    </entry>
    <entry id="NCPL_BASE_PERIOD" value="day">
      <type>char</type>
      <valid_values>hour,day,year,decade</valid_values>
      <desc>Base period associated with NCPL coupling frequency.
    This xml variable is only used to set the driver namelist variables,
    atm_cpl_dt, lnd_cpl_dt, ocn_cpl_dt, ice_cpl_dt, glc_cpl_dt, rof_cpl_dt, wav_cpl_dt, and esp_dt.</desc>
    </entry>
    <entry id="ATM_NCPL" value="192">
      <type>integer</type>
      <desc>Number of atm coupling intervals per NCPL_BASE_PERIOD.
    This is used to set the driver namelist atm_cpl_dt, equal to basedt/ATM_NCPL,
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="LND_NCPL" value="$ATM_NCPL">
      <type>integer</type>
      <desc>Number of land coupling intervals per NCPL_BASE_PERIOD.
    This is used to set the driver namelist atm_cpl_dt, equal to basedt/LND_NCPL,
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="ICE_NCPL" value="$ATM_NCPL">
      <type>integer</type>
      <desc>Number of ice coupling intervals per NCPL_BASE_PERIOD.
    This is used to set the driver namelist ice_cpl_dt, equal to basedt/ICE_NCPL
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="OCN_NCPL" value="$ATM_NCPL">
      <type>integer</type>
      <desc>Number of ocn coupling intervals per NCPL_BASE_PERIOD.
    Thisn is used to set the driver namelist ocn_cpl_dt, equal to basedt/OCN_NCPL
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="GLC_NCPL" value="$ATM_NCPL">
      <type>integer</type>
      <desc>Number of glc coupling intervals per NCPL_BASE_PERIOD.</desc>
    </entry>
    <entry id="GLC_AVG_PERIOD" value="yearly">
      <type>char</type>
      <valid_values>glc_coupling_period,yearly</valid_values>
      <desc>Period at which coupler averages fields sent to GLC.
    This supports doing the averaging to GLC less frequently than GLC is called
    (i.e., separating the averaging frequency from the calling frequency).
    This is useful because there are benefits to only averaging the GLC inputs
    as frequently as they are really needed (yearly for CISM), but GLC needs to
    still be called more frequently than that in order to support mid-year restarts.

    Setting GLC_AVG_PERIOD to 'glc_coupling_period' means that the averaging is
    done exactly when the GLC is called (governed by GLC_NCPL).

    IMPORTANT: In order to restart mid-year when running with CISM, you MUST specify GLC_AVG_PERIOD = 'yearly'.
    If using GLC_AVG_PERIOD = 'glc_coupling_period' with CISM, you can only restart on year boundaries.
    </desc>
    </entry>
    <entry id="ROF_NCPL" value="8">
      <type>integer</type>
      <desc>Number of rof coupling intervals per NCPL_BASE_PERIOD.
    This is used to set the driver namelist rof_cpl_dt, equal to basedt/ROF_NCPL
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="WAV_NCPL" value="$ATM_NCPL">
      <type>integer</type>
      <desc>Number of wav coupling intervals per NCPL_BASE_PERIOD.
    This is used to set the driver namelist wav_cpl_dt, equal to basedt/WAV_NCPL
    where basedt is equal to NCPL_BASE_PERIOD in seconds.</desc>
    </entry>
    <entry id="CPL_SEQ_OPTION" value="TIGHT">
      <type>char</type>
      <valid_values>TIGHT,OPTION1,OPTION2</valid_values>
      <desc>
      OPTION1 (like RASM_OPTION1 in CPL7) runs prep_ocn_avg,
      BEFORE the aoflux and ocnalb calculations, thereby reducing
      most of the lags and field inconsistency but still allowing the
      ocean to run concurrently with the ice and atmosphere.
      OPTION2 (like CESM1_MOD in CPL7) runs prep_ocn_avg,
      AFTER the aoflux and ocnalb calculations, thereby permitting maximum
      concurrency
      TIGHT (like CESM1_MOD_TIGHT), is a tight coupling run sequence
    </desc>
    </entry>
  </group>
  <group id="run_desc">
    <entry id="LOGDIR" value="$CASEROOT/logs">
      <type>char</type>
      <desc>Extra copies of the component log files will be saved here.</desc>
    </entry>
    <entry id="CASESTR" value="UNSET">
      <type>char</type>
      <desc>case description</desc>
    </entry>
    <entry id="RUNDIR" value="$CIME_OUTPUT_ROOT/$CASE/run">
      <type>char</type>
      <desc>
      The directory where the executable will be run.
      By default this is set to EXEROOT/../run.
      RUNDIR allows you to keep the run directory separate from the build directory
    </desc>
    </entry>
  </group>
  <group id="run_begin_stop_restart">
    <entry id="RUN_TYPE" value="startup">
      <type>char</type>
      <valid_values>startup,hybrid,branch</valid_values>
      <desc>
      Determines the model run initialization type.
      This setting is only important for the initial run of a production run when the
      CONTINUE_RUN variable is set to FALSE.  After the initial run, the CONTINUE_RUN
      variable is set to TRUE, and the model restarts exactly using input
      files in a case, date, and bit-for-bit continuous fashion.
      Default: startup.
      -- In a startup run (the default), all components are initialized
      using baseline states.  These baseline states are set independently by
      each component and can include the use of restart files, initial
      files, external observed data files, or internal initialization (i.e.,
      a cold start). In a startup run, the coupler sends the start date to
      the components at initialization. In addition, the coupler does not
      need an input data file.  In a startup initialization, the ocean model
      does not start until the second ocean coupling (normally the second
      day).
      -- In a branch run, all components are initialized using a consistent
      set of restart files from a previous run (determined by the
      RUN_REFCASE and RUN_REFDATE variables in env_run.xml).  The case name
      is generally changed for a branch run, although it does not have to
      be. In a branch run, setting RUN_STARTDATE is ignored because the
      model components obtain the start date from their restart datasets.
      Therefore, the start date cannot be changed for a branch run. This is
      the same mechanism that is used for performing a restart run (where
      CONTINUE_RUN is set to TRUE in the env_run.xml) Branch runs are
      typically used when sensitivity or parameter studies are required, or
      when settings for history file output streams need to be modified
      while still maintaining bit-for-bit reproducibility. Under this
      scenario, the new case is able to produce an exact bit-for-bit restart
      in the same manner as a continuation run IF no source code or
      component namelist inputs are modified. All models use restart files
      to perform this type of run.  RUN_REFCASE and RUN_REFDATE are required
      for branch runs.
      To set up a branch run, locate the restart tar file or restart
      directory for RUN_REFCASE and RUN_REFDATE from a previous run, then
      place those files in the RUNDIR directory.
      --- In a hybrid run the model is initialized as a startup, BUT uses
      initialization datasets FROM A PREVIOUS case.  This
      is somewhat analogous to a branch run with relaxed restart
      constraints.  A hybrid run allows users to bring together combinations
      of initial/restart files from a previous case (specified by
      RUN_REFCASE) at a given model output date (specified by
      RUN_REFDATE). Unlike a branch run, the starting date of a hybrid run
      (specified by RUN_STARTDATE) can be modified relative to the reference
      case. In a hybrid run, the model does not continue in a bit-for-bit
      fashion with respect to the reference case. The resulting climate,
      however, should be continuous provided that no model source code or
      namelists are changed in the hybrid run.  In a hybrid initialization,
      the ocean model does not start until the second ocean coupling
      (normally the second day), and the coupler does a cold start without
      a restart file.
    </desc>
    </entry>
    <entry id="RUN_REFDIR" value="ccsm4_init">
      <type>char</type>
      <desc>
      Reference directory containing RUN_REFCASE data - used for hybrid or branch runs
    </desc>
    </entry>
    <entry id="RUN_REFCASE" value="case.std">
      <type>char</type>
      <desc>
      Reference case for hybrid or branch runs
    </desc>
    </entry>
    <entry id="RUN_REFDATE" value="0001-01-01">
      <type>char</type>
      <desc>
      Reference date for hybrid or branch runs (yyyy-mm-dd)
    </desc>
    </entry>
    <entry id="RUN_REFTOD" value="00000">
      <type>char</type>
      <desc>
      Reference time of day (seconds) for hybrid or branch runs (sssss)
    </desc>
    </entry>
    <entry id="GET_REFCASE" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      Flag for automatically prestaging the refcase restart dataset.
      If TRUE, then the refcase data is prestaged into the executable directory
    </desc>
    </entry>
    <entry id="RUN_STARTDATE" value="2000-01-01">
      <type>char</type>
      <desc>
      Run start date (yyyy-mm-dd). Only used for startup or hybrid runs.
    </desc>
    </entry>
    <entry id="START_TOD" value="0">
      <type>integer</type>
      <desc>
      Run start time-of-day
    </desc>
    </entry>
    <entry id="STOP_OPTION" value="nmonths">
      <type>char</type>
      <valid_values>none,never,nsteps,nseconds,nminutes,nhours,ndays,nmonths,nyears,date,end</valid_values>
      <desc>
      Sets the run length along with STOP_N and STOP_DATE
    </desc>
    </entry>
    <entry id="STOP_N" value="2">
      <type>integer</type>
      <desc>
      Provides a numerical count for $STOP_OPTION.
    </desc>
    </entry>
    <entry id="STOP_DATE" value="-999">
      <type>integer</type>
      <desc>
      Alternative date yyyymmdd date option, sets the run length with STOP_OPTION and STOP_N
      negative value implies off
    </desc>
    </entry>
    <entry id="REST_OPTION" value="nmonths">
      <type>char</type>
      <valid_values>none,never,nsteps,nseconds,nminutes,nhours,ndays,nmonths,nyears,date,end</valid_values>
      <desc>
      sets frequency of model restart writes (same options as STOP_OPTION)
    </desc>
    </entry>
    <entry id="REST_N" value="2">
      <type>integer</type>
      <desc>
      sets model restart writes with REST_OPTION and REST_DATE
    </desc>
    </entry>
    <entry id="REST_DATE" value="$STOP_DATE">
      <type>char</type>
      <desc>
      Alternative date in yyyymmdd format
      sets model restart write date with REST_OPTION and REST_N
    </desc>
    </entry>
    <entry id="PAUSE_OPTION" value="never">
      <type>char</type>
      <valid_values>none,never,nsteps,nseconds,nminutes,nhours,ndays,nmonths,nyears</valid_values>
      <desc>
      Sets the pause frequency along with PAUSE_N
    </desc>
    </entry>
    <entry id="PAUSE_N" value="0">
      <type>integer</type>
      <desc>
      Provides a numerical count for $PAUSE_OPTION.
    </desc>
    </entry>
    <entry id="PAUSE_ACTIVE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      Pause the model at times specified by PAUSE_OPTION and PAUSE_N.
      Components 'pause' by writing a restart file.
    </desc>
      <values>
        <value compclass="ATM">FALSE</value>
        <value compclass="CPL">FALSE</value>
        <value compclass="OCN">FALSE</value>
        <value compclass="WAV">FALSE</value>
        <value compclass="GLC">FALSE</value>
        <value compclass="ICE">FALSE</value>
        <value compclass="ROF">FALSE</value>
        <value compclass="LND">FALSE</value>
      </values>
    </entry>
    <entry id="ESP_RUN_ON_PAUSE" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      ESP component runs after driver 'pause cycle' If any component
      'pauses' (see PAUSE_OPTION,
      PAUSE_N and PAUSE_ACTIVE_XXX XML variables),
      the ESP component (if present) will be run to process the
      component 'pause' (restart) files and set any required 'resume'
      signals.  If true, esp_cpl_dt and esp_cpl_offset settings are
      ignored.  default: false
    </desc>
    </entry>
    <entry id="CONTINUE_RUN" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      A setting of TRUE implies a continuation run
      When you first begin a branch, hybrid or startup run, CONTINUE_RUN
      must be set to FALSE. When you successfully run and get a restart
      file, you will need to change CONTINUE_RUN to TRUE for the remainder
      of your run. This variable determines if the run is a restart run.
      Set to FALSE when initializing a startup, branch or hybrid case.
      Set to TRUE when continuing a run.
    </desc>
    </entry>
    <entry id="MEDIATOR_READ_RESTART" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      A setting of TRUE implies a continuation run for mediator only
    </desc>
    </entry>
    <entry id="RESUBMIT" value="11">
      <type>integer</type>
      <desc>If RESUBMIT is greater than 0, then case will automatically resubmit
    Enables the model to automatically resubmit a new run.  To get
    multiple runs, set RESUBMIT greater than 0, then RESUBMIT will be
    decremented and the case will be resubmitted.  The case will stop automatically
    resubmitting when the RESUBMIT value reaches 0.
    Long runs can easily outstrip supercomputer queue time limits. For
    this reason, a case is usually run as a series of jobs, each
    restarting where the previous finished.
    </desc>
    </entry>
    <entry id="RESUBMIT_SETS_CONTINUE_RUN" value="TRUE">
      <type>logical</type>
      <desc>This flag controls whether the RESUBMIT flag causes
      CONTINUE_RUN to toggle from FALSE to TRUE.  The default is
      TRUE.  This flag might be used in conjunction with COMP_RUN_BARRIERS for
      timing tests.
    </desc>
    </entry>
    <entry id="RUN_WITH_SUBMIT" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Logical to determine whether run has been submitted with the submit script or not</desc>
    </entry>
    <entry id="JOB_IDS" value="case.run:6338451.desched1, case.st_archive:6338452.desched1">
      <type>char</type>
      <desc>List of job ids for most recent case.submit</desc>
    </entry>
    <entry id="JOB_PRIORITY" value="premium">
      <type>char</type>
      <valid_values>regular,premium,economy</valid_values>
      <desc>job priority for systems supporting this option</desc>
    </entry>
  </group>
  <group id="run_data_archive">
    <entry id="DOUT_S" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Logical to turn on short term archiving.
    If TRUE, short term archiving will be turned on.</desc>
    </entry>
    <entry id="SYSLOG_N" value="900">
      <type>integer</type>
      <desc>system workload snapshot frequency (in seconds, if greater than 0; disabled otherwise)</desc>
    </entry>
    <entry id="DOUT_S_SAVE_INTERIM_RESTART_FILES" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Logical to archive all interim restart files, not just those at eor
    If TRUE, perform short term archiving on all interim restart files,
    not just those at the end of the run. By default, this value is FALSE.
    The restart files are saved under the specific component directory
    ($DOUT_S_ROOT/$CASE/$COMPONENT/rest rather than the top-level $DOUT_S_ROOT/$CASE/rest directory).
    Interim restart files are created using the REST_N and REST_OPTION variables.
    This is for expert users ONLY and requires expert knowledge.
    We will not document this further in this guide.</desc>
    </entry>
  </group>
  <group id="build_def">
    <entry id="GMAKE" value="gmake">
      <type>char</type>
      <valid_values/>
      <desc>GNU make command</desc>
    </entry>
    <entry id="GMAKE_J" value="16">
      <type>integer</type>
      <valid_values/>
      <desc>Number of processors for gmake</desc>
    </entry>
  </group>
  <group id="run_flags">
    <entry id="CHECK_TIMING" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>logical to diagnose model timing at the end of the run</desc>
    </entry>
    <entry id="PROFILE_PAPI_ENABLE" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Enables the papi hardware counters in gptl
    The papi library must be included in the build step for
    this to work.</desc>
    </entry>
    <entry id="ESMF_VERBOSITY_LEVEL" value="off">
      <type>char</type>
      <valid_values>off,low,high,max</valid_values>
      <desc>
      Determines the verbosity level in ESMF log files
      "off": no verbosity
      "low": some verbosity
      "high": more verbosity
      "max": all lower 16 bits
      By default, the verbosity level is set to "off"
    </desc>
    </entry>
    <entry id="ESMF_PROFILING_LEVEL" value="0">
      <type>char</type>
      <desc>
      Determines the profiling level in ESMF log files
      by default, it is set to 0 (only run method execution timings)
    </desc>
    </entry>
    <entry id="COMP_RUN_BARRIERS" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Turns on component barriers for component timing.
          This variable is for testing and debugging only and should never
          be set for a production run.
    </desc>
    </entry>
    <entry id="INFO_DBUG" value="1">
      <type>integer</type>
      <valid_values>0,1,2,3,4,5,6,7,8,9</valid_values>
      <desc>level of debug output, 0=minimum, 1=normal, 2=more, 3=too much</desc>
    </entry>
    <entry id="BFBFLAG" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>turns on coupler bit-for-bit reproducibility with varying pe counts</desc>
    </entry>
    <entry id="SAVE_TIMING" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>logical to save timing files in rundir</desc>
    </entry>
    <entry id="TPROF_TOTAL" value="0">
      <type>integer</type>
      <desc>Determines number of times profiler is called over the model run period.
    This sets values for tprof_option and tprof_n that determine the timing output file frequency
    </desc>
    </entry>
    <entry id="TIMER_DETAIL" value="2">
      <type>integer</type>
      <desc>
    integer indicating maximum detail level to profile. This xml
    variable is used to set the namelist variable
    timing_detail_limit. This namelist variable is used by perf_mod
    (in $CIMEROOT/src/share/timing/perf_mod.F90) to turn timers off
    and on depending on calls to the routine t_adj_detailf. If in the
    code a statement appears like t_adj_detailf(+1), then the current
    timer detail level is incremented by 1 and compared to the
    time_detail_limit obtained from the namelist.  If the limit is
    exceeded then the timer is turned off.
    </desc>
    </entry>
    <entry id="TIMER_LEVEL" value="4">
      <type>integer</type>
      <desc>Maximum code stack depth of enabled timers.</desc>
    </entry>
    <entry id="FLDS_WISO" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Turn on the passing of water isotope fields through the coupler</desc>
    </entry>
  </group>
  <group id="run_domain">
    <entry id="PTS_LAT" value="-999.99">
      <type>real</type>
      <desc>Latitude of grid location, in single column mode interpolate datasets to this location
          in single point mode assume all datasets are at this location</desc>
    </entry>
    <entry id="PTS_LON" value="-999.99">
      <type>real</type>
      <desc>Longitude of grid location, in single column mode interpolate datasets to this location
          in single point mode assume all datasets are at this location</desc>
    </entry>
    <entry id="PTS_DOMAINFILE" value="UNSET">
      <type>char</type>
      <desc>used only if if PTS_LAT and PTS_LON are greater than or
          equal to 0.  If this is the case then if PTS_DOMAINFILE is not
          equal to UNSET a nearest neighbor search of PTS_DOMAINFILE using
          PTS_LAT and PTS_LON will be done and the component mesh will have
          this nearest neighbor value. </desc>
    </entry>
    <entry id="LND_DOMAIN_FILE" value="UNSET">
      <type>char</type>
      <desc>lnd domain file</desc>
    </entry>
    <entry id="LND_DOMAIN_PATH" value="$DIN_LOC_ROOT/share/domains">
      <type>char</type>
      <desc>path of lnd domain file</desc>
    </entry>
    <entry id="ATM_DOMAIN_MESH" value="$DIN_LOC_ROOT/share/meshes/ne120pg3_ESMFmesh_cdf5_c20211018.nc">
      <type>char</type>
      <desc>atm mesh file (full pathname)</desc>
    </entry>
    <entry id="LND_DOMAIN_MESH" value="$DIN_LOC_ROOT/share/meshes/ne120pg3_ESMFmesh_cdf5_c20211018.nc">
      <type>char</type>
      <desc>lnd mesh file (full pathname)</desc>
    </entry>
    <entry id="ROF_DOMAIN_MESH" value="$DIN_LOC_ROOT/share/meshes/r05_nomask_c110308_ESMFmesh.nc">
      <type>char</type>
      <desc>rof mesh file (full pathname)</desc>
    </entry>
    <entry id="WAV_DOMAIN_MESH" value="UNSET">
      <type>char</type>
      <desc>wav mesh file (full pathname)</desc>
    </entry>
    <entry id="ICE_DOMAIN_MESH" value="$DIN_LOC_ROOT/share/meshes/ne120pg3_ESMFmesh_cdf5_c20211018.nc">
      <type>char</type>
      <desc>ice mesh file (full pahtname)</desc>
    </entry>
    <entry id="OCN_DOMAIN_MESH" value="$DIN_LOC_ROOT/share/meshes/ne120pg3_ESMFmesh_cdf5_c20211018.nc">
      <type>char</type>
      <desc>ocn mesh file (full pathname)</desc>
    </entry>
    <entry id="GLC_DOMAIN_MESH" value="UNSET">
      <type>char</type>
      <desc>glc mesh file (full pathname)</desc>
    </entry>
    <entry id="MASK_MESH" value="$DIN_LOC_ROOT/share/meshes/tx0.1v3_ESMFmesh_cdf5_c20211011.nc">
      <type>char</type>
      <desc>mask mesh file (full pathname)</desc>
    </entry>
    <entry id="LND2ROF_FMAPNAME" value="unset">
      <type>char</type>
      <desc>lnd2rof flux mapping file</desc>
    </entry>
    <entry id="ROF2LND_FMAPNAME" value="unset">
      <type>char</type>
      <desc>rof2lnd flux mapping file</desc>
    </entry>
    <entry id="ROF2OCN_LIQ_RMAPNAME" value="unset">
      <type>char</type>
      <desc>rof2ocn runoff mapping file</desc>
    </entry>
    <entry id="ROF2OCN_ICE_RMAPNAME" value="unset">
      <type>char</type>
      <desc>rof2ocn runoff mapping file</desc>
    </entry>
    <entry id="EPS_FRAC" value="1.0e-02">
      <type>char</type>
      <desc>Error tolerance for differences in fractions in domain checking</desc>
    </entry>
    <entry id="EPS_AAREA" value="9.0e-07">
      <type>real</type>
      <desc>Error tolerance for differences in atm/land areas in domain checking</desc>
    </entry>
    <entry id="EPS_AMASK" value="1.0e-13">
      <type>real</type>
      <desc>Error tolerance for differences in atm/land masks in domain checking</desc>
    </entry>
    <entry id="EPS_AGRID" value="1.0e-12">
      <type>real</type>
      <desc>Error tolerance for differences in atm/land lat/lon in domain checking</desc>
    </entry>
    <entry id="EPS_OAREA" value="1.0e-01">
      <type>real</type>
      <desc>Error tolerance for differences in ocean/ice lon/lat in domain checking</desc>
    </entry>
    <entry id="EPS_OMASK" value="1.0e-06">
      <type>real</type>
      <desc>Error tolerance for differences in ocean/ice lon/lat in domain checking</desc>
    </entry>
    <entry id="EPS_OGRID" value="1.0e-02">
      <type>real</type>
      <desc>Error tolerance for differences in ocean/ice lon/lat in domain checking</desc>
    </entry>
  </group>
  <group id="run_din">
    <entry id="NODENAME_REGEX" value="UNSET">
      <type>char</type>
      <desc>
      A regular expression to match machine node names to ACME machine.
    </desc>
    </entry>
    <entry id="NODE_FAIL_REGEX">
      <type>char</type>
      <desc>
      A regular expression to search for an indication that a run failure was caused by a node failure
      and should therefore be re-attempted.
    </desc>
    </entry>
    <entry id="PROXY" value="UNSET">
      <type>char</type>
      <desc>
      Proxy (if any) setting for http_proxy to allow web access on this machine.
    </desc>
    </entry>
    <entry id="TEST" value="FALSE">
      <type>logical</type>
      <desc>
      Indicates to case.submit that this is a test case.
    </desc>
    </entry>
    <entry id="DIN_LOC_ROOT" value="$ENV{CESMDATAROOT}/inputdata">
      <type>char</type>
      <desc>
      The root directory of all CIME and component input data for the selected machine.
      This is usually a shared disk area.
      Default values for the target machine are in the
      $CIMEROOT/machines/config_machines.xml
    </desc>
    </entry>
    <entry id="DIN_LOC_ROOT_CLMFORC" value="$ENV{CESMDATAROOT}/inputdata/atm/datm7">
      <type>char</type>
      <desc>CLM-specific root directory for CLM type input forcing data
    This directory will only be used for I (CLM/DATM) compsets and only
    for datm forcing data that is NOT checked into the svn repository
    (datasets other than the Qian or single-point forcing).
    This is usually a shared disk area.
    Default values for the target machine are in the
    $CIMEROOT/machines/config_machines.xml</desc>
    </entry>
    <entry id="DIN_STAGING_ROOT" value="UNSET">
      <type>char</type>
      <desc>
      On some systems the filesystem of DIN_LOC_ROOT is not available on compute nodes and
      data must be staged to a temporary location.  If this variable is defined it will
      be used as the root directory of an inputdata staging area.
      Default values for the target machine are in the
      $CIMEROOT/machines/config_machines.xml
    </desc>
    </entry>
  </group>
  <group id="run_dout">
    <entry id="DOUT_S_ROOT" value="$CIME_OUTPUT_ROOT/archive/$CASE">
      <type>char</type>
      <desc>Root directory for short term archiving. This directory must be visible to compute nodes.</desc>
    </entry>
  </group>
  <group id="run_mpi">
    <entry id="MPI_RUN_COMMAND" value="UNSET">
      <type>char</type>
      <desc>override the mpi run command, do not include model executable</desc>
    </entry>
  </group>
  <group id="run_pio">
    <entry id="PIO_REARR_COMM_TYPE" value="p2p">
      <type>char</type>
      <valid_values>p2p,coll,default</valid_values>
      <desc>pio rearranger communication type</desc>
    </entry>
    <entry id="PIO_REARR_COMM_FCD" value="2denable">
      <type>char</type>
      <valid_values>2denable,io2comp,comp2io,disable,default</valid_values>
      <desc>pio rearranger communication flow control direction</desc>
    </entry>
    <entry id="PIO_REARR_COMM_MAX_PEND_REQ_COMP2IO" value="-2">
      <type>integer</type>
      <valid_values/>
      <desc>pio rearranger communication max pending requests (io2comp) :
       -2 implies that CIME internally calculates the value ( = 64),
       -1 implies no bound on max pending requests
        0 implies that MPI_ALLTOALL will be used
    </desc>
    </entry>
    <entry id="PIO_REARR_COMM_ENABLE_HS_COMP2IO" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>pio rearranger communiation options (comp2io) : TRUE implies enable handshake </desc>
    </entry>
    <entry id="PIO_REARR_COMM_ENABLE_ISEND_COMP2IO" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>pio rearranger communiation options (comp2io) : TRUE implies enable isend</desc>
    </entry>
    <entry id="PIO_REARR_COMM_MAX_PEND_REQ_IO2COMP" value="64">
      <type>integer</type>
      <valid_values/>
      <desc>pio rearranger communication max pending requests (io2comp) : -1 implies no bound on max pending requests </desc>
    </entry>
    <entry id="PIO_REARR_COMM_ENABLE_HS_IO2COMP" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>pio rearranger communiation options (io2comp) : TRUE implies enable handshake</desc>
    </entry>
    <entry id="PIO_REARR_COMM_ENABLE_ISEND_IO2COMP" value="TRUE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>pio rearranger communiation options (io2comp) : TRUE implies enable isend</desc>
    </entry>
    <entry id="PIO_DEBUG_LEVEL" value="0">
      <type>integer</type>
      <desc>pio debug level</desc>
    </entry>
    <entry id="PIO_BLOCKSIZE" value="-1">
      <type>integer</type>
      <desc>pio blocksize for box decompositions</desc>
    </entry>
    <entry id="PIO_BUFFER_SIZE_LIMIT" value="-1">
      <type>integer</type>
      <desc>pio buffer size limit for pnetcdf output</desc>
    </entry>
    <entry id="PIO_ASYNC_INTERFACE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>TRUE implies perform asynchronous i/o</desc>
      <values>
        <value compclass="ATM">FALSE</value>
        <value compclass="CPL">FALSE</value>
        <value compclass="OCN">FALSE</value>
        <value compclass="WAV">FALSE</value>
        <value compclass="GLC">FALSE</value>
        <value compclass="ICE">FALSE</value>
        <value compclass="ROF">FALSE</value>
        <value compclass="LND">FALSE</value>
        <value compclass="ESP">FALSE</value>
      </values>
    </entry>
    <entry id="PIO_TYPENAME">
      <type>char</type>
      <valid_values>netcdf,netcdf4p,netcdf4c,pnetcdf,nothing</valid_values>
      <desc>pio io type</desc>
      <values>
        <value compclass="ATM">pnetcdf</value>
        <value compclass="CPL">pnetcdf</value>
        <value compclass="OCN">pnetcdf</value>
        <value compclass="WAV">pnetcdf</value>
        <value compclass="GLC">pnetcdf</value>
        <value compclass="ICE">pnetcdf</value>
        <value compclass="ROF">pnetcdf</value>
        <value compclass="LND">pnetcdf</value>
        <value compclass="ESP">pnetcdf</value>
      </values>
    </entry>
    <entry id="PIO_NETCDF_FORMAT">
      <type>char</type>
      <valid_values>classic,64bit_offset,64bit_data</valid_values>
      <desc>pio netcdf format (ignored for netcdf4p and netcdf4c)
    https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html
    </desc>
      <values>
        <value compclass="ATM">64bit_offset</value>
        <value compclass="CPL">64bit_offset</value>
        <value compclass="OCN">64bit_offset</value>
        <value compclass="WAV">64bit_offset</value>
        <value compclass="GLC">64bit_offset</value>
        <value compclass="ICE">64bit_offset</value>
        <value compclass="ROF">64bit_offset</value>
        <value compclass="LND">64bit_offset</value>
        <value compclass="ESP">64bit_offset</value>
      </values>
    </entry>
    <entry id="PIO_STRIDE">
      <type>integer</type>
      <desc>
     stride in compute comm of io tasks for each component, if this value is -99 it will
     be computed based on PIO_NUMTASKS and number of compute tasks
    </desc>
      <values>
        <value compclass="ATM">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="CPL">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="OCN">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="WAV">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="GLC">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="ICE">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="ROF">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="LND">$MAX_MPITASKS_PER_NODE</value>
        <value compclass="ESP">$MAX_MPITASKS_PER_NODE</value>
      </values>
    </entry>
    <entry id="PIO_REARRANGER">
      <type>integer</type>
      <valid_values>1,2</valid_values>
      <desc>pio rearranger choice box=1, subset=2 </desc>
      <values>
        <value compclass="ATM">2</value>
        <value compclass="CPL">2</value>
        <value compclass="OCN">2</value>
        <value compclass="WAV">2</value>
        <value compclass="GLC">2</value>
        <value compclass="ICE">2</value>
        <value compclass="ROF">2</value>
        <value compclass="LND">2</value>
        <value compclass="ESP">2</value>
      </values>
    </entry>
    <entry id="PIO_ROOT">
      <type>integer</type>
      <desc>pio root processor relative to component root</desc>
      <values>
        <value compclass="ATM">1</value>
        <value compclass="CPL">1</value>
        <value compclass="OCN">1</value>
        <value compclass="WAV">1</value>
        <value compclass="GLC">1</value>
        <value compclass="ICE">1</value>
        <value compclass="ROF">1</value>
        <value compclass="LND">1</value>
        <value compclass="ESP">1</value>
      </values>
    </entry>
    <entry id="PIO_NUMTASKS">
      <type>integer</type>
      <desc>
      pio number of io tasks, if this value is -99 it will be computed based on PIO_STRIDE and
      number of tasks
    </desc>
      <values>
        <value compclass="ATM">-99</value>
        <value compclass="CPL">-99</value>
        <value compclass="OCN">-99</value>
        <value compclass="WAV">-99</value>
        <value compclass="GLC">-99</value>
        <value compclass="ICE">-99</value>
        <value compclass="ROF">-99</value>
        <value compclass="LND">-99</value>
        <value compclass="ESP">-99</value>
      </values>
    </entry>
  </group>
  <group id="external_tools">
    <entry id="PRERUN_SCRIPT">
      <type>char</type>
      <desc>External script to be run before model completion</desc>
    </entry>
    <entry id="POSTRUN_SCRIPT">
      <type>char</type>
      <desc>External script to be run after model completion</desc>
    </entry>
    <entry id="DATA_ASSIMILATION">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc> Run the external tool pointed to by DATA_ASSIMILATION_SCRIPT after the model run completes </desc>
      <values>
        <value compclass="ATM">FALSE</value>
        <value compclass="CPL">FALSE</value>
        <value compclass="OCN">FALSE</value>
        <value compclass="WAV">FALSE</value>
        <value compclass="GLC">FALSE</value>
        <value compclass="ICE">FALSE</value>
        <value compclass="ROF">FALSE</value>
        <value compclass="LND">FALSE</value>
      </values>
    </entry>
    <entry id="DATA_ASSIMILATION_CYCLES" value="1">
      <type>integer</type>
      <valid_values/>
      <desc> Number of model run - data assimilation steps to complete </desc>
    </entry>
    <entry id="DATA_ASSIMILATION_SCRIPT">
      <type>char</type>
      <valid_values/>
      <desc>External script to be run after model completion</desc>
    </entry>
    <entry id="EXTERNAL_WORKFLOW" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>whether the case uses an external workflow driver </desc>
    </entry>
  </group>
  <group id="data_models">
    <entry id="FORCE_PROGNOSTIC_FOR_DATAMODELS" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>if true, all data models are expected to get input sent back from the mediator</desc>
    </entry>
  </group>
  <group id="run_debug">
    <entry id="CREATE_ESMF_PET_FILES" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>if true, create ESMF PET log files even if there is no error encountered </desc>
    </entry>
  </group>
  <group id="run_component_cpl">
    <entry id="CPL_ALBAV" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>
      Only used for compsets with DATM and POP (currently C, G and J):
      If true, compute albedos to work with daily avg SW down
      If false (default), albedos are computed with the assumption that downward
      solar radiation from the atm component has a diurnal cycle and zenith-angle
      dependence. This is normally the case when using an active atm component
      If true, albedos are computed with the assumption that downward
      solar radiation from the atm component is a daily average quantity and
      does not have a zenith-angle dependence. This is often the case when
      using a data atm component. Only used for compsets with DATM and POP (currently C, G and J).
      NOTE: This should really depend on the datm forcing and not the compset per se.
      So, for example, whether it is set in a J compset should depend on
      what datm forcing is used.
    </desc>
    </entry>
    <entry id="CPL_EPBAL" value="off">
      <type>char</type>
      <valid_values>off,ocn</valid_values>
      <desc>
      Only used for compsets with DATM and POP (currently C, G and J):
      If ocn, ocn provides EP balance factor for precipitation.
      Provides EP balance factor for precip for POP. A factor computed by
      POP is applied to precipitation so that precipitation balances
      evaporation and ocn global salinity does not drift. This is intended
      for use when coupling POP to a DATM. Only used for C, G and J compsets.
      Default is off
    </desc>
    </entry>
    <entry id="LND_SETS_DUST_EMIS_DRV_FLDS" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>If CTSM will set the dust settings in drv_flds_in (TRUE), or if ATM (i.e. CAM) will - DO NOT EDIT (set by compset name)</desc>
    </entry>
  </group>
  <group id="med_history">
    <entry id="HIST_OPTION" value="never">
      <type>char</type>
      <valid_values>none,never,nsteps,nseconds,nminutes,nhours,ndays,nmonths,nyears,date,end</valid_values>
      <desc>Sets driver snapshot history file frequency (like REST_OPTION)</desc>
    </entry>
    <entry id="HIST_N" value="-999">
      <type>integer</type>
      <valid_values/>
      <desc>Sets driver snapshot history file frequency (like REST_N)</desc>
    </entry>
    <entry id="HIST_DATE" value="-999">
      <type>integer</type>
      <valid_values/>
      <desc>yyyymmdd format, sets coupler snapshot history date (like REST_DATE)</desc>
    </entry>
  </group>
  <group id="run_budgets">
    <entry id="BUDGETS" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>logical that turns on diagnostic budgets for driver</desc>
    </entry>
  </group>
  <group id="run_co2">
    <entry id="CCSM_CO2_PPMV" value="284.7">
      <type>real</type>
      <valid_values/>
      <desc>
      Mechanism for setting the CO2 value in ppmv for
      CLM if CLM_CO2_TYPE is constant or for
      POP if OCN_CO2_TYPE is constant.
    </desc>
    </entry>
  </group>
  <group id="run_glc">
    <entry id="GLC_NEC" value="10">
      <type>integer</type>
      <valid_values>1,3,5,10,36</valid_values>
      <desc>Number of glacier elevation classes used in CLM.
    Used by both CLM and the coupler (even if CISM is not running, and only SGLC is used).</desc>
    </entry>
    <entry id="GLC_TWO_WAY_COUPLING" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>Whether the glacier component feeds back to the rest of the system
      This affects:
      (1) Whether CLM updates its areas based on glacier areas sent from GLC
      (2) Whether GLC sends fluxes (e.g., calving fluxes) to the coupler
      Note that this is set to TRUE by default for TG compsets - even though there are
      no feedbacks for TG compsets, this enables extra coupler diagnostics for these
      compsets.</desc>
    </entry>
  </group>
  <group id="run_physics">
    <entry id="TFREEZE_SALTWATER_OPTION" value="mushy">
      <type>char</type>
      <valid_values>minus1p8,linear_salt,mushy</valid_values>
      <desc>Freezing point calculation for salt water.</desc>
    </entry>
  </group>
  <group id="run_component_cam">
    <entry id="CAM_NML_USE_CASE" value="hist_cam_lt">
      <type>char</type>
      <valid_values/>
      <desc>CAM namelist use_case.  Provides the use_case option for the
      CAM build-namelist utility (which is called from
      $CASEROOT/Buildconf/cam.buildnml).  The CAM build-namelist
      leverages groups of namelist options (use cases) that are often
      paired with the CAM configure options.  These use cases are xml
      files located in
      $CIMEROOT/../components/cam/bld/namelist_files/use_cases.
      In general, this variable should not be modified for supported
      component sets (compsets).  Recommendation: If you want to
      modify this value for your experiment, use your own user-defined
      component sets.</desc>
    </entry>
    <entry id="CAM_NAMELIST_OPTS">
      <type>char</type>
      <valid_values/>
      <desc>CAM specific namelist settings for -namelist option Provides
      options to the -namelist argument for the CAM build-namelist
      utility.  This should be reserved for component set
      specification. Users should modify CAM namelists only via the
      $CASEROOT/user_nl_cam file.</desc>
    </entry>
    <entry id="CAM_STREAM_NDEP_YEAR_FIRST" value="1850">
      <type>char</type>
      <desc>Nitrogen deposition data year first</desc>
    </entry>
    <entry id="CAM_STREAM_NDEP_YEAR_LAST" value="2015">
      <type>char</type>
      <desc>Nitrogen deposition data year last</desc>
    </entry>
    <entry id="CAM_STREAM_NDEP_YEAR_ALIGN" value="1850">
      <type>char</type>
      <desc>Nitrogen deposition align CAM_STREAM_NDEP_YEAR_FIRST with this model year</desc>
    </entry>
    <entry id="CAM_STREAM_NDEP_DATA_FILENAME" value="$DIN_LOC_ROOT/lnd/clm2/ndepdata/fndep_clm_hist_b.e21.BWHIST.f09_g17.CMIP6-historical-WACCM.ensmean_1849-2015_monthly_0.9x1.25_c180926.nc">
      <type>char</type>
      <desc>Nitrogen deposition data filename</desc>
    </entry>
    <entry id="CAM_STREAM_NDEP_MESH_FILENAME" value="$DIN_LOC_ROOT/share/meshes/fv0.9x1.25_141008_polemod_ESMFmesh.nc">
      <type>char</type>
      <desc>Nitrogen deposition mesh filename (corresponding to the CAM_STREAM_NDEP_DATA_FILENAME)</desc>
    </entry>
  </group>
  <group id="run_component_ctsm">
    <entry id="LND_TUNING_MODE" value="clm6_0_cam7.0">
      <type>char</type>
      <desc>Tuning parameters and initial conditions should be optimized for what CLM model version and what meteorlogical forcing combination?
          Options for all combinations of CLM physics and atm forcing are given. The buildnml and namelist_defaults will narrow it down to the ones
          that have been tuned. The buildnml will also warn you if a tuning combination is based on another set.
          Atm forcing options:
               CRUv7
               GSWP3
               CAM4.0
               CAM5.0
               CAM6.0
               CAM7.0
               QIAN   (not tuned)
               1PT    (not tuned)
               NLDAS2 (not tuned)
               ERA5   (not tuned)
          Other atm forcing options are invalid to run CLM and will result in an error.
    </desc>
      <valid_values>clm5_0_cam6.0,clm5_0_cam7.0,clm5_0_cam5.0,clm5_0_cam4.0,clm5_0_GSWP3v1,clm5_0_CRUv7,clm5_0_QIAN,clm5_0_1PT,clm5_0_NLDAS2,clm5_0_ERA5,clm4_5_CRUv7,clm4_5_GSWP3v1,clm4_5_QIAN,clm4_5_cam6.0,clm4_5_cam7.0,clm4_5_cam5.0,clm4_5_cam4.0,clm4_5_1PT,clm4_5_NLDAS2,clm4_5_ERA5,clm5_1_CRUv7,clm5_1_GSWP3v1,clm5_1_cam6.0,clm5_1_QIAN,clm5_1_1PT,clm5_1_NLDAS2,clm5_1_ERA5,clm6_0_CRUv7,clm6_0_GSWP3v1,clm6_0_cam6.0,clm6_0_cam7.0,clm6_0_cam5.0,clm6_0_cam4.0,clm6_0_QIAN,clm6_0_1PT,clm6_0_NLDAS2,clm6_0_ERA5</valid_values>
    </entry>
    <entry id="CLM_PHYSICS_VERSION" value="clm6_0">
      <type>char</type>
      <valid_values>clm4_5,clm5_0,clm5_1,clm6_0</valid_values>
      <desc>Overall physics version to use.
    This sets the default values for many different namelist options.
    This is typically set by the compset.</desc>
    </entry>
    <entry id="CLM_CONFIGURATION" value="clm">
      <type>char</type>
      <valid_values>clm,nwp</valid_values>
      <desc>Sets CLM default namelist options related to model configuration.
    clm: Configuration used for climate applications (CLM)
    nwp: Configuration used for numerical weather prediction applications
    </desc>
    </entry>
    <entry id="CLM_STRUCTURE" value="standard">
      <type>char</type>
      <valid_values>standard,fast</valid_values>
      <desc>Sets CLM default namelist options related to model structure.
    standard: Standard model structure, allowing for more subgrid heterogeneity,
    deeper soil, etc., at the cost of slower speeds.
    fast: Simplified model structure, achieving faster speeds at the cost of less
    subgrid heterogeneity, shallower soil, etc.
    </desc>
    </entry>
    <entry id="CLM_NML_USE_CASE" value="20thC_transient">
      <type>char</type>
      <desc>CLM namelist use_case.
      Determines the use-case that will be sent to the CLM build-namelist utility.
      This is normally set by the component set. This is an advanced flag and should only be
      used by expert users.</desc>
    </entry>
    <entry id="CLM_BLDNML_OPTS" value="-bgc sp">
      <type>char</type>
      <desc>CLM build-namelist options</desc>
    </entry>
    <entry id="CLM_CO2_TYPE" value="diagnostic">
      <type>char</type>
      <valid_values>constant,diagnostic,prognostic</valid_values>
      <desc>Determines how CLM will determine where CO2 is set.
      If value is constant, it will be set to CCSM_CO2_PPMV,
      if value is either diagnostic or prognostic, the atmosphere model
      MUST send it to CLM. CLM_CO2_TYPE is normally set by the specific
      compset, since it HAS to be coordinated with settings for the
      atmospheric model. Do not modify this variable. If you want to modify for
      your experiment, use your own user-defined component set
      This is an advanced flag and should only be used by expert users.</desc>
    </entry>
    <entry id="CLM_NAMELIST_OPTS">
      <type>char</type>
      <desc>CLM-specific namelist settings for -namelist option in the CLM
      build-namelist. CLM_NAMELIST_OPTS is normally set as a compset variable
      and in general should not be modified for supported compsets.
      It is recommended that if you want to modify this value for your experiment,
      you should use your own user-defined component sets via using create_newcase
      with a compset_file argument.
      This is an advanced flag and should only be used by expert users.</desc>
    </entry>
    <entry id="CLM_ACCELERATED_SPINUP" value="off">
      <type>char</type>
      <valid_values>on,sasu,off</valid_values>
      <desc>Turn on any settings for accellerating the model spinup. SASU is to run the Semi-Analytic Spin-Up with the CN soil matrix method.
    </desc>
    </entry>
    <entry id="CLM_USRDAT_NAME" value="UNSET">
      <type>char</type>
      <desc>Resolution name for user-created resolutions. This is especially used
      for single point and regional resolutions created via subset_data from
      the global datasets. This should be set when you use CLM_USRDAT as the grid
      to create_newcase.  The default value is UNSET.
      For NEON cases, this can be set to either NEON or NEON.PRISM, the latter of which would
      use PRISM precipitation instead of the default NEON precipitation. NEON cases then also
      use the variable NEONSITE to specify the exact site. PLUMBER cases use the variable 
      PLUMBER2SITE to specify the exact site.</desc>
    </entry>
    <entry id="CLM_USRDAT_DIR" value="UNSET">
      <type>char</type>
      <desc>Directory name for user-created surface, landuse, and datm datasets.
      This is used as an argument in user_mods namelists (e.g. user_nl_clm,
      user_nl_datm_streams) generated with the subset_data script. Users
      should modify this variable (in shell_commands or elsewhere) to set the
      location of user-created data. The default value is UNSET.</desc>
    </entry>
    <entry id="CLM_FORCE_COLDSTART" value="off">
      <type>char</type>
      <valid_values>on,off</valid_values>
      <desc>Flag to the CLM build-namelist command to force CLM to do a
      cold start (finidat will be set to blanks).
      A value of on forces the model to spin up from a cold-start
      (arbitrary initial conditions). Setting this value in the xml file will take
      precedence over any settings for finidat in the $CASEROOT/user_nl_clm file.</desc>
    </entry>
    <entry id="NEONSITE">
      <type>char</type>
      <valid_values>
      ABBY,BLAN,CPER,DEJU,GRSM,HEAL,KONA,LENO,NIWO,ONAQ,PUUM,SERC,SRER,TALL,TREE,WOOD,
      BARR,BONA,DCFS,DELA,GUAN,JERC,KONZ,MLBS,NOGP,ORNL,RMNP,SJER,STEI,TEAK,UKFS,WREF,
      BART,CLBJ,DSNY,HARV,JORN,LAJA,MOAB,OAES,OSBS,SCBI,SOAP,STER,TOOL,UNDE,YELL,
      NEON_PRECIP.ABBY,NEON_PRECIP.BLAN,NEON_PRECIP.CPER,NEON_PRECIP.DEJU,NEON_PRECIP.GRSM,
      NEON_PRECIP.HEAL,NEON_PRECIP.KONA,NEON_PRECIP.LENO,NEON_PRECIP.NIWO,NEON_PRECIP.ONAQ,
      NEON_PRECIP.PUUM,NEON_PRECIP.SERC,NEON_PRECIP.SRER,NEON_PRECIP.TALL,NEON_PRECIP.TREE,
      NEON_PRECIP.WOOD,NEON_PRECIP.BARR,NEON_PRECIP.BONA,NEON_PRECIP.DCFS,NEON_PRECIP.DELA,
      NEON_PRECIP.GUAN,NEON_PRECIP.JERC,NEON_PRECIP.KONZ,NEON_PRECIP.MLBS,NEON_PRECIP.NOGP,
      NEON_PRECIP.ORNL,NEON_PRECIP.RMNP,NEON_PRECIP.SJER,NEON_PRECIP.STEI,NEON_PRECIP.TEAK,
      NEON_PRECIP.UKFS,NEON_PRECIP.WREF,NEON_PRECIP.BART,NEON_PRECIP.CLBJ,NEON_PRECIP.DSNY,
      NEON_PRECIP.HARV,NEON_PRECIP.JORN,NEON_PRECIP.LAJA,NEON_PRECIP.MOAB,NEON_PRECIP.OAES,
      NEON_PRECIP.OSBS,NEON_PRECIP.SCBI,NEON_PRECIP.SOAP,NEON_PRECIP.STER,NEON_PRECIP.TOOL,
      NEON_PRECIP.UNDE,NEON_PRECIP.YELL,
      PRISM_PRECIP.ABBY,PRISM_PRECIP.BLAN,PRISM_PRECIP.CPER,PRISM_PRECIP.GRSM,
      PRISM_PRECIP.KONA,PRISM_PRECIP.LENO,PRISM_PRECIP.NIWO,PRISM_PRECIP.ONAQ,
      PRISM_PRECIP.SERC,PRISM_PRECIP.SRER,PRISM_PRECIP.TALL,PRISM_PRECIP.TREE,
      PRISM_PRECIP.WOOD,PRISM_PRECIP.DCFS,PRISM_PRECIP.DELA,PRISM_PRECIP.JERC,
      PRISM_PRECIP.KONZ,PRISM_PRECIP.MLBS,PRISM_PRECIP.NOGP,PRISM_PRECIP.ORNL,
      PRISM_PRECIP.RMNP,PRISM_PRECIP.SJER,PRISM_PRECIP.STEI,PRISM_PRECIP.TEAK,
      PRISM_PRECIP.UKFS,PRISM_PRECIP.WREF,PRISM_PRECIP.BART,PRISM_PRECIP.CLBJ,
      PRISM_PRECIP.DSNY,PRISM_PRECIP.HARV,PRISM_PRECIP.JORN,PRISM_PRECIP.MOAB,
      PRISM_PRECIP.OAES,PRISM_PRECIP.OSBS,PRISM_PRECIP.SCBI,PRISM_PRECIP.SOAP,
      PRISM_PRECIP.STER,PRISM_PRECIP.UNDE,PRISM_PRECIP.YELL,
    </valid_values>
      <desc>Name of site for NEON tower data</desc>
    </entry>
    <entry id="NEONVERSION" value="latest">
      <type>char</type>
      <valid_values>v1,v2,v3,latest</valid_values>
      <desc>Version id of Neon data</desc>
    </entry>
    <entry id="PLUMBER2SITE">
      <type>char</type>
      <valid_values>
      AR-SLu,AT-Neu,AU-ASM,AU-Cow,AU-Cpr,AU-Ctr,AU-Cum,AU-DaP,AU-DaS,AU-Dry,AU-Emr,AU-Gin,AU-GWW,AU-How,AU-Lit,
      AU-Otw,AU-Rig,AU-Rob,AU-Sam,AU-Stp,AU-TTE,AU-Tum,AU-Whr,AU-Wrr,AU-Ync,BE-Bra,BE-Lon,BE-Vie,BR-Sa3,BW-Ma1,CA-NS1,
      CA-NS2,CA-NS4,CA-NS5,CA-NS6,CA-NS7,CA-Qcu,CA-Qfo,CA-SF1,CA-SF2,CA-SF3,CH-Cha,CH-Dav,CH-Fru,CH-Oe1,CN-Cha,CN-Cng,
      CN-Dan,CN-Din,CN-Du2,CN-HaM,CN-Qia,CZ-wet,DE-Bay,DE-Geb,DE-Gri,DE-Hai,DE-Kli,DE-Meh,DE-Obe,DE-Seh,DE-SfN,DE-Tha,
      DE-Wet,DK-Fou,DK-Lva,DK-Ris,DK-Sor,DK-ZaH,ES-ES1,ES-ES2,ES-LgS,ES-LMa,ES-VDA,FI-Hyy,FI-Kaa,FI-Lom,FI-Sod,FR-Fon,
      FR-Gri,FR-Hes,FR-LBr,FR-Lq1,FR-Lq2,FR-Pue,GF-Guy,HU-Bug,ID-Pag,IE-Ca1,IE-Dri,IT-Amp,IT-BCi,IT-CA1,IT-CA2,IT-CA3,
      IT-Col,IT-Cpz,IT-Isp,IT-Lav,IT-LMa,IT-Mal,IT-MBo,IT-Noe,IT-Non,IT-PT1,IT-Ren,IT-Ro1,IT-Ro2,IT-SR2,IT-SRo,JP-SMF,
      NL-Ca1,NL-Hor,NL-Loo,PL-wet,PT-Esp,PT-Mi1,PT-Mi2,RU-Che,RU-Fyo,RU-Zot,SD-Dem,SE-Deg,UK-Gri,UK-Ham,UK-PL3,US-AR1,
      US-AR2,US-ARM,US-Aud,US-Bar,US-Bkg,US-Blo,US-Bo1,US-Cop,US-FPe,US-GLE,US-Goo,US-Ha1,US-Ho1,US-KS2,US-Los,US-Me2,
      US-Me4,US-Me6,US-MMS,US-MOz,US-Myb,US-Ne1,US-Ne2,US-Ne3,US-NR1,US-PFa,US-Prr,US-SP1,US-SP2,US-SP3,US-SRG,US-SRM,
      US-Syv,US-Ton,US-Tw4,US-Twt,US-UMB,US-Var,US-WCr,US-Whs,US-Wkg,ZA-Kru,ZM-Mon,
    </valid_values>
      <desc>Name of site for PLUMBER tower data</desc>
    </entry>
  </group>
  <group id="build_component_cice">
    <entry id="CICE_MODE" value="prescribed">
      <type>char</type>
      <valid_values>prognostic,prescribed,thermo_only</valid_values>
      <desc>Option to the CICE configure utility for the -mode argument (default is prognostic)</desc>
    </entry>
    <entry id="CICE_CONFIG_OPTS" value=" -phys cice5 ">
      <type>char</type>
      <desc>CICE configure options, see CICE configure utility for details.
      It is recommended that if you want to modify this value for your experiment,
      you should use your own user-defined component sets via using create_newcase
      with a compset_file argument.
      This is an advanced flag and should only be used by expert users.
    </desc>
    </entry>
  </group>
  <group id="run_component_cice">
    <entry id="CICE_NAMELIST_OPTS">
      <type>char</type>
      <desc>CICE specific namelist settings for -namelist option</desc>
    </entry>
  </group>
  <group id="run_component_docn">
    <entry id="DOCN_MODE" value="prescribed">
      <type>char</type>
      <valid_values>prescribed,sst_aquap1,sst_aquap2,sst_aquap3,sst_aquap4,sst_aquap5,sst_aquap6,sst_aquap7,sst_aquap8,sst_aquap9,sst_aquap10,sst_aquapfile,som,som_aquap,sst_aquap_constant,interannual,cplhist,multilev,multilev_dom</valid_values>
      <desc> DOCN mode. The data ocean component (DOCN) always returns SSTs to the
    driver. The atmosphere/ocean fluxes are computed in the
    coupler. Therefore, the data ocean model does not compute fluxes like
    the data ice model. DOCN has two distinct modes of operation. It can
    run as a pure data model, reading in ocean SSTs (normally
    climatological) from input datasets, performing time/spatial
    interpolations, and passing these to the coupler. Alternatively,
    DOCN can compute updated SSTs by running as a slab ocean model where
    bottom ocean heat flux convergence and boundary layer depths are read
    in and used with the atmosphere/ocean and ice/ocean fluxes obtained
    from the driver.
    --- A setting of prescribed assumes the only field in the input stream is SST.
    It also assumes the SST is in Celsius and must be converted to Kelvin.
    All other fields are set to zero except for ocean salinity, which is set to a
    constant reference salinity value. Normally the ice fraction data is found in
    the same data files that provide SST data to the data ocean model. They are
    normally found in the same file because the SST and ice fraction data are derived
    from the same observational data sets and are consistent with each other.
    --- Settings of som (slab ocean model) or  som_aquap (aquaplanet slab ocean) are
    prognostic modes which compute a prognostic sea surface temperature and a
    freeze/melt potential (surface Q-flux) used by the sea ice model.  This
    calculation requires an external SOM forcing data file that includes
    ocean mixed layer depths and bottom-of-the-slab Q-fluxes.
    Scientifically appropriate bottom-of-the-slab Q-fluxes are normally
    ocean resolution dependent and are derived from the ocean model output
    of a fully coupled CCSM run.  Note that while this mode runs out of
    the box, the default SOM forcing file is not scientifically
    appropriate and is provided for testing and development purposes only.
    Users must create scientifically appropriate data for their particular
    application.  A tool is available to derive valid SOM forcing.
    --- A setting of sst_aquapN (where "N" is an integer index value) is a
    type of prescribed SST mode used specifically for an aquaplanet setup in
    which global SSTs correspond to an analytic form set by the index value.
    Currently, indices for 10 SST profiles are supported [e.g., index 3 corresponds
    to the "QOBS" profile of Neale and Hoskins (2001, Atmos. Sci. Lett.)].
    With source code modifications, it is possible for users to create their own
    analytic SST distributions and match them to indices 11 or greater.
    </desc>
    </entry>
    <entry id="DOCN_AQPCONST_VALUE" value="-1">
      <type>real</type>
      <valid_values/>
      <desc>Sets globally constant SST value</desc>
    </entry>
    <entry id="DOCN_SOMAQP_DATAFILE" value="unset">
      <type>char</type>
      <valid_values/>
      <desc>Sets SOM aquaplanet file</desc>
    </entry>
    <entry id="SSTICE_STREAM" value="CAMDATA">
      <type>char</type>
      <valid_values/>
      <desc>Prescribed SST and ice coverage stream name.
    Sets SST and ice coverage stream name.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
    <entry id="SSTICE_DATA_FILENAME" value="/glade/campaign/cesm/cesmdata/cseg/inputdata/atm/cam/sst/sst_HadOIBl_bc_1x1_1850_2021_SST4K_c241009.nc">
      <type>char</type>
      <valid_values/>
      <desc>Prescribed SST and ice coverage data file name.
    Sets SST and ice coverage data file name.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
    <entry id="DOCN_CPLHIST_YR_ALIGN" value="1">
      <type>integer</type>
      <valid_values/>
      <desc>
      Simulation year corresponding to DOCN_CPLHIST_YR_START. A common usage
      is to set this to RUN_STARTDATE. With this setting, the forcing
      in the first year of the run will be the forcing of year
      DOCN_CPLHIST_YR_START. Another use case is to align the calendar
      of transient forcing with the model calendar. For example,
      setting DOCN_CPLHIST_YR_ALIGN=DOCN_CPLHIST_YR_START will lead to
      the forcing calendar being the same as the model calendar. The
      forcing for a given model year would be the forcing of the same
      year. This would be appropriate in transient runs where the
      model calendar is setup to span the same year range as the
      forcing data.
    </desc>
    </entry>
    <entry id="DOCN_CPLHIST_YR_START" value="1">
      <type>integer</type>
      <valid_values/>
      <desc>starting year to loop data over</desc>
    </entry>
    <entry id="DOCN_CPLHIST_YR_END" value="1">
      <type>integer</type>
      <valid_values/>
      <desc>ending year to loop data over</desc>
    </entry>
    <entry id="DOCN_SKIP_RESTART_READ" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc> If set to true, than docn restarts will not be read on a continuation run.
    </desc>
    </entry>
    <entry id="DOCN_IMPORT_FIELDS" value="none">
      <type>char</type>
      <desc>none or colon deliminted string of import fields that DOCN will advertise</desc>
    </entry>
  </group>
  <group id="run_component_cam_sstice">
    <entry id="SSTICE_MESH_FILENAME" value="$DIN_LOC_ROOT/atm/cam/sst/sst_HadOIBl_bc_1x1_clim_c101029_ESMFmesh_120520.nc">
      <type>char</type>
      <valid_values/>
      <desc>Prescribed SST and ice coverage mesh file name.
    Sets SST and ice coverage grid file name for prescribed runs.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
    <entry id="SSTICE_YEAR_ALIGN" value="1850">
      <type>integer</type>
      <valid_values/>
      <desc>The model year that corresponds to SSTICE_YEAR_START on the data file.
    Prescribed SST and ice coverage data will be aligned so that the first year of
    data corresponds to SSTICE_YEAR_ALIGN in the model. For instance, if the first
    year of prescribed data is the same as the first year of the model run, this
    should be set to the year given in RUN_STARTDATE.
    If SSTICE_YEAR_ALIGN is later than the model's starting year, or if the model is
    run after the prescribed data ends (as determined by SSTICE_YEAR_END), the
    default behavior is to assume that the data from SSTICE_YEAR_START to
    SSTICE_YEAR_END cyclically repeats. This behavior is controlled by the
    "taxmode" stream option; see the data model documentation for more details.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
    <entry id="SSTICE_YEAR_START" value="1850">
      <type>integer</type>
      <valid_values/>
      <desc>The first year of data to use from SSTICE_DATA_FILENAME.
    This is the first year of prescribed SST and ice coverage data to use. For
    example, if a data file has data for years 0-99, and SSTICE_YEAR_START is 10,
    years 0-9 in the file will not be used.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
    <entry id="SSTICE_YEAR_END" value="2021">
      <type>integer</type>
      <valid_values/>
      <desc>The last year of data to use from SSTICE_DATA_FILENAME.
    This is the last year of prescribed SST and ice coverage data to use. For
    example, if a data file has data for years 0-99, and value is 49,
    years 50-99 in the file will not be used.
    This is only used when DOCN_MODE=prescribed.</desc>
    </entry>
  </group>
  <group id="run_component_mosart">
    <entry id="MOSART_IGNORE_WARNINGS" value="FALSE">
      <type>logical</type>
      <valid_values>TRUE,FALSE</valid_values>
      <desc>If warnings in namelist setttings from buildnml should be ignored or not</desc>
    </entry>
    <entry id="MOSART_SIM_YEAR" value="1850">
      <type>char</type>
      <valid_values/>
      <desc>Simulation year to start from -- build-namelist options (currently not used)</desc>
    </entry>
  </group>
</file>
